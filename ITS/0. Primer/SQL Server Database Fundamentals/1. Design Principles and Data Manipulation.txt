Getting Started:
Course Introduction:
A database is used to organise and store data in an electronic format.
There are multiple types of databases, such as flat-file or hierarchical,
but the most widely used database is the relational database, that stores data in
tables that are related or connected to one another.
In this course, you will learn what databases and Relational Database Management
Systems (RDBMS) are, and be introduced to different database models.
We'll also cover how to use the Data Manipulation Language (DML) statements to
query data and manipulate result sets, as well as how to update and delete data,
and see how databases maintain the integrity of your records.

Introducing Databases:
Let's get started with just a basic introduction about databases and what they are.
And it is, in essence, just a collection of related data that's organized into a
logical structure.
Now we'll come back to the related data and logical structure in a moment.
But the data is stored electronically and can be processed to deliver meaningful
information to end users.
In other words, it's not meant to just be stored but rather to also be retrieved.
So for example, if you're storing sales information, you can certainly retrieve
just a single sales record, but that doesn't give you a lot of information.
But if you were to retrieve, let's say, thousands or even possibly millions of
sales records, then you can really start to ascertain some meaningful information.
We can see how sales are moving, which products are selling, where, during which
time frames, to which customers.
And you can gather up all kinds of information that is useful to your organization.

Now the data in a database is organized by fields, which are the vertical columns;
records, which are the horizontal rows;
and the collection of all of it put together, which creates the table.
Now the fields or the columns, in this case, have headers, which tell us what
we're looking at.
So the column headers are:
Employee code, First Name, Last Name, and Benefit package.
So that as we read down that column, that's all we're looking at.
We're seeing nothing but employee codes in the first column.
Then as you read across, each record, it's the collection of entries for each
individual column that creates each row or each record.
And then when you put all the records together, you have the table.
Now the databases themselves have a structure as well, and this is that logical
structure that was referenced earlier.
They can be what's known as flat, which is usually just a single table or possibly
multiple tables that don't have anything to do with each other.
They're just completely separate structures that are holding data.

A flat database might be what we're looking at right here.
It is simply a list of names and their benefit package.
Perhaps a little more realistically or day-to-day, if you will, an employee
directory or even a phone book.
It simply lists the people, their phone numbers, and their addresses, and that's
it. That's all there is to it. There is no other structure.

A hierarchical structure is organized into these parent-child types of
relationships, wherein, as you move down the hierarchy, you typically become more
specific.
As you move back up the hierarchy, you typically become more generalized.
So we have a Department entity, which is subdivided into IT and Sales, in this
case, which is then further subdivided into Contract employees and Permanent
employees in the IT department.
So it's not unlike a file management system, where you create a parent folder and
then have subfolders in that folder.

And then finally, you have the relational, and this is probably the most common
and it will be the focus of this course.
The relational database has multiple tables that has connected or related
information.
So in this example, we see that there is an Orders table, wherein a sales manager,
for example, might be entering in the sales that they are making.
But the finance manager is interested in entering customer information, but the
two are related.
Because, as a finance manager creates a record for a new customer, that customer
might turn around and generate an order.
While the order has to belong to somebody, and of course, it is the customer.
So if you look in the Orders table, you see that there is a reference to the
customer.
But that's all you need to do is simply say, this order belongs to that particular
customer.
You can then use that value that identifies the customer to go and look up all of
their customer information, so there is a relationship.
Customers generate orders. That is the relationship between those two tables.

Now with relational databases, you simply see it is a collection of tables, or
it's usually many tables.
And it's made up of data that is simply related to each other.
So there is always some kind of a field that's common between two or more tables.
However, what you'll typically see in almost all cases in relational databases is
that there is one column known as the primary key, and this is to provide a unique
identifier for each row.
And in this example here, in the Customers table, it's the ID field.
This uniquely identifies each and every customer.
Because if you were to just put in something like customer name, that would
probably repeat; all kinds of times people have the same names.
So you need something that's unique that can never be confused with anything else.
And then you also see it in the Orders table, the Order Number is the unique
identifying field for any one particular order.
But the customer that's referenced in there does actually borrow the ID from the
Customers table.
So if you were to look at what an actual record might look like, let's just say,
it's the very first order for the very first customer.

Order number 001 might be generated by customer 001.
So you would see in the Customers table, there would only be a single entry for
customer 001.
The next customer would be customer 002. The next customer would be customer 003.
So you would only uniquely see each individual customer one time.
But of course, any given customer can make possibly thousands or even millions of
orders or they might not make any, it doesn't really matter.
But you would see customer 001 possibly show up many times in the Orders table.
So one customer generates many orders, but any one order must only belong to the
unique single customer referenced in the related table.

Now the data can be reorganized and grouped as well without modifying any of the
original tables.
In other words, I could query out information about the customers.
So if I was the sales manager, for example, I might have a sales territory.
I might want to see only customers that are in my sales territory.
So I can absolutely do that.
I can group them together without having to make any changes.
All that's necessary in the Customer table would be a field called sales territory.
Something along those lines that I can extract the records that are meaningful to
me, without making any kind of changes to the way the tables are structured or the
way the data is entered.
Now there are a few rules of the relational model.
All data is stored as values in the table.
So you simply enter a value into each field, and it must be accessible to users
using the table name, the primary key, and the field name without any knowledge of
the storage location.
So it doesn't matter to them where the records are stored, in which database, on
which server.
They just need to be able to know the customer information.
For example, I want to see customer ID number 1 from the Customers table.
It doesn't matter to me where it's stored, I just want to be able retrieve that
information from my application.
It must also support null values.
Not every field has an appropriate value.
For example, if you were storing the customer's fax number, well not everybody has
a fax number, so you need to be able to leave some fields blank.
It must support at least one language.
In this case, this is known as SQL or Structured Query Language – that's the
primary language of databases.
The result sets should be modifiable.
So if you do run a query that says, show me all the customers in my sales
territory, you have to be able to make changes to any one particular record.
For example, a person might move to a different territory.
You should be able to make changes to the result set that is returned by a query.
And it must support what's known as single commands to change that data.
And in the Structured Query Language, it is simply known as an update statement.
You simply make your change by modifying the original record.
But you have to be able to also prevent changes, if that change undermines an
integrity rule.
And that means that you can't make a change to a field that would effectively
mess up the rest of the database.
In other words, if you were to change a customer's ID, that would mess up all of
the orders that were entered using that person's ID.
So there are certain fields that you can't change.
So those are the basics of databases and particularly the relational model.

DBMS and RDBMS:
A database management system (DBMS), is in essence the software that is used to
access the databases, to create them, and ultimately to manage the databases as
well.
Now as far as the DBMS itself goes, it does allow your users to add, modify,
delete, and retrieve data.
But they typically don't work directly with the DBMS.
The DBMS works with the operating system to manage the data.
So what that means is that users, those who are entering records and retrieving
records and just doing their day-to-day operations, will likely use different
applications to do so.
Perhaps a web-based interface or a custom in-house developed application – that's
how they interact with the database.
But the DBMS itself is the software that manages who is doing what and what they
can do.
For example, security.
Certain users maybe should not have access to certain information.
In a practical example, only the HR department should have access to the employee
information table.
Well it's the job of the DBMS to implement that security.
So that a standard sales manager, for example, does not have access to that
employee information.

So the other thing it does is to control all of the concurrent users.
Because in very large environments, you can have hundreds, possibly thousands of
users, all accessing the database in different ways at the same time.
So again, it is the job of the DBMS to manage all of that, to control all of the
traffic and ensure that everybody is able to do whatever it is that they need to
do.
As far as actually using the interface of the database management system, that
generally does not fall to end users.
It is usually the administrators, the technical staff that manage the databases,
who will use the DBMS itself directly.

Now the management systems for relational databases include the following examples,
and these are only a few.
But Microsoft, their server-based component, their higher-end one, is simply
called SQL Server, you'll hear most people say.
MySQL is an open-source example of the same style of database, if you will, more
of a higher-level server-based; usually larger databases that are supporting very
high numbers of users and very high numbers of records.
So MySQL as an open-source product is actually free.
But as of the time of this recording, MySQL is generally overseen by, if you will,
by Oracle.
And Oracle is another product that falls under the server-based database component.
And finally, Microsoft Access is more of a desktop-level.
That would be something that you might see end users just creating their own
personal databases with but certainly not something that you would support, you
know, hundreds of users or thousands of users accessing millions upon millions of
records.
Microsoft Access just simply wouldn't be up to the task for that size database –
so a much more personal-level application.
Now as far as the servers go, it can be either a physical computer or a virtual
server, that's fine, that are used to store the databases.
There is high-level support for data access, so again you can have tremendous
numbers of users all accessing the data at the same time.
And they simply contain the DBMS.
So you go and you sit yourself down in front of a server and you install the
software for the database management system.
So again, if you're talking about Microsoft SQL, for example, you would install
that on one of your Windows Server 2012 systems or whatever version you're
currently running.
You can then have one default instance and multiple named instances.
Now what this is, in essence, is the ability to install a product multiple times.
It allows you to create different configurations, and this actually was not
available in some of the older versions of the product.
It's been around for a while now, but if you go back quite a ways, you could
install a product only one time and configure it in a particular way.

You didn't have any limits on the number of databases you could create; that was
still unlimited really.
But it was the configuration, particularly with things like the security of the
database and the language support and what's known as the collation, how data is
treated in terms of alphabetical sorting and character recognition and things like
that.
So now you can have multiple instances, and each one can be configured differently.
So that I can have security configuration A on instance A, and security
configuration B on instance B.
And then I can have language A on instance C, and language B on instance D.
So you can have these completely separate configurations.
Those are your instances.
And the default is simply the one that you get when you install the product for
the first time.
After that, if you want additional instances, you can call them whatever you want.
And you can, in fact, also rename the default one if you want to.

Microsoft SQL Server is an instance, if you will, of the product running on
Windows as a Service.
So you see that there will actually be an executable file called sqlservice.exe.
So if you just go to your Windows Services console on a system that's running SQL
Server, you will see that file running.
That indicates that SQL has been installed on that system and it is ready to
service the database application.
Multiple servers can be used to ensure availability and performance.
This is a feature known as fault tolerance or clustering, wherein you can have
several servers maintaining copies of a single database.
So that if one of them fails, you have others ready to assume the workload of that
database.
And as far as your end users are concerned, they don't see any disruption in
service.
So this makes it very available and ensures high performance levels.

As far as database servers go in SQL Server, the databases themselves are stored
in a couple of different file types.
So it is still just a file like any other application to store the information,
but there are three types of files.
The first one is known as a primary database file and has the extension mdf,
that's Microsoft data file. That's basically all it is.
It's just a file that contains information, very much like an Excel file contains
spreadsheets.
So that in essence is your data.
Now you can have secondary files if you want to, extension ndf, that's up to you.
They aren't required but they can help you organize the database a little more
effectively, particularly if it's very large.
That's where you see a lot of secondary files come into play.
Because if it is an exceptionally large database, when you need to do
administrative tasks such as backing up the database, if it's all in a single
primary file you have to back up the whole database.
But there may not be very much of it that has changed since the last backup.
So it might take a very long time, even though there's very few changes.
Well secondary files, you can say, will only back up that particular ndf file
because that's the one that all the changes have occurred to.
These other ndfs have hardly changed it all.
So you can do a very specialized or particular backup.
And finally, an ldf is what's known as a transaction log, often referred to as
TLOG for short.
And this is what stores all of the changes that have occurred.
So as new records come in, as things get edited and deleted, the transaction
log – the transaction literally means something has changed – it logs all of
those entries.
So it's very useful for recovery purposes.
In the event that the database fails, you can use the transaction log to restore
any kind of changes that have not yet been backed up.
So those are the three types of files that you'll find in just about every
database instance, but again the secondary files aren't required.
So you may not see them, but quite commonly they are used.

Introducing SQL Server Management Studio (SSMS):
We're going to take a look now at the SQL Server Management Studio, which is the
administrative interface for Microsoft's SQL Server.
So when you first launch the product, you are asked to connect to the particular
server on which the product is installed, or you can in fact also connect to any
other remote server that is accessible.
You can use a single management interface to connect to any and all of your
database servers.
It really does not matter where they are as long as you have physical connectivity.
So in this case, this is the name of the server, and here you see it will ask you
for the authentication method.
And if you go with the fairly standard default installation in a Microsoft
environment, it will go with what's known as Windows Authentication, which simply
means you are using the same set of credentials that you used to sign in to
Windows.
So you can see, with that, I don't even have a choice, in terms of changing the
User name and Password. It simply picks up on my existing identification.
Now the other choice is that you can be authenticated by the SQL Server itself.
Now we'll be talking about the security a little bit later on.
But those are the only two options when it comes to Authentication.
You either use your Windows identity, or you can use one that is stored directly
in the SQL Server itself.
And this would be for people who do not have a Windows identity.
So I do, and there are my credentials there.
So all I have to do is choose Connect.

And it makes the connection, and then I see all of my objects over here on the
left-hand side, which is under my Object Explorer.
So the main thing that you're interested in, in most cases, of course, are the
databases themselves.
So here we see all of the databases that are installed on this server.
And there really isn't any limit to the number of databases.
It really just comes down to the storage and the resources that are available on
that server.
So we can expand this, and you will see that there are a few databases that are
here already.
And these were some examples from previous courses and things like that, while
some of them are sample databases that you can obtain from Microsoft.
And in fact, that's what these two right here are, this AdventureWorks2012 and
AdventureWorks Data Warehouse.
These are freely available databases that you can just download from Microsoft
and use for your own purposes purely to help learn the product.
So a lot of SQL Servers might have these databases on them.
Now the other thing that you will always find is this one right here, the System
Databases.
And these are databases that are always present on all SQL Servers because they
help control and maintain the configuration of the other databases that you have.
So for example, if I expand this here, you'll find that there is one called master.
And master has various entries for every other database that you define.
So in essence, there are two categories.
The System Databases are maintained by SQL Server itself.
They help to control the system.
All the other databases are what's known as user-defined; you create them.
But every time you create a new database, an entry gets created in the master
database that says, you just created this particular database, and it has
properties like the time that you created it, the size, the storage location of
the files.
All of those sorts of things are maintained in these system databases.
Now we'll go through those a little bit later on as well, but those are your two
primary categories of databases – System and user-defined.
Now there is a lot more here than just the databases.
If you continue to scroll down, you see that there is Security.
And this is where you control the users that are accessing the environment.
So Logins and user accounts are managed within the Security.
You also see that there are various roles, that you can assign people to, so that
they have certain administrative abilities and certainly various other features
with respect to security.
That again, we'll also cover later on, but for the time being we just want to get
familiar with the interface.

Then you see certain other features that are fairly common such as Replication,
which is to maintain additional copies of the databases.
And AlwaysOn High Availability, and this is where you maintain redundant copies of
databases, so that if one fails, there is always another copy of the same database
available to assume the services.
So that your clients don't notice any disruption of services in the event of a
failure.
Under Management, you'll find fairly standard day-to-day tasks that you might have
to do such as automated jobs and things along those lines.
You see here, Data Collection and Resource Governor, as well, for performance
management and just keeping an eye on how the server is performing.
Maintenance Plans to do things like backups and cleaning up of the databases.
Mail that you can configure, so that you can receive alerts.
In the event that you do configure an automated backup, for example, you can
receive an e-mail that informs you that the backup succeeded or failed.
So there are a number of components that we'll certainly be going through.
But those are some of your basic objects that are available within the SQL Server
environment.
And again, this is what you see, what's called the Object Explorer so that you can
see all of these.
Now once you do start to get in and start working with a database, you can just
select it and expand that.
And you'll see all of the objects that are particular to just that specific
database.
So here we see are the Tables.
So this is where we would see the actual data storage for those tables within that
specific database.
So we'll certainly be doing some work in there.
And then we'll also be looking at some Views, which are affectively saved queries.
This is how you start retrieving data out of the database to give you some
meaningful information.
So we can expand this as well, and you see that there's already several Views that
have been defined in there.
And they help to retrieve the data, usually for purposes such as reporting.
So that I can simply create things like sales totals and present them to my users.
So that's just some of the basics, and we'll certainly be doing a lot more work in
the SQL Server Management Studio as we move through the course.

Lesson Test:
Q1: You need to do some database maintenance and create a backup:
	Object Explorer -> Management

Q2: What do you call the unique identifier that links data record sets between
    different tables?
	Primary Key

Q3: In a SQL Server, databases are stored in three files.
    What are the extensions of these files?
	.mdf, .ndf, .ldf
-----------------------------------------------------------------------------------------
Database Design:
Data Types:
When you store information in a table in a database, you need to inform the
database what kind of information you are supplying.
And this is what's known as the data type.
And every field that you define in every table has a data type.
So it's an attribute, a characteristic that specifies how this information is
stored and how it's being used.
Now in essence, you use the data type that provides the most precision or the
greatest value range depending on what it is you're storing, and we'll see some
examples of that in a minute.
But it is possible to convert from one data type to another in a couple of
different instances.
And it can be done either automatically by, for example, a SQL Server, and this is
known as an implicit conversion, which simply will convert from one type to
another.
Or you can do it manually yourself using various statements such as CAST or
CONVERT in a command in SQL Server, which means that you simply want to explicitly
control yourself how data types are converted.
And common examples of this include when you're doing calculations, you might be
taking field 1 and doing a mathematical calculation with field 2.
Now normally with mathematical calculations, you need to deal with numbers.
But you don't always have numbers in the two fields, so SQL Server is able to
recognize this and, in some cases, do an implicit conversion.
For example, a text-based field does allow you to store numeric information.
So you might have any kind of numeric value in a field that actually has a text
type of data.
So with that, if you were to, let's say, just multiply it against another field
that is actually a numeric data type, SQL Server will pick up on that, and it will
complete the conversion automatically and give you an answer.
But if you know that you're dealing with a non-numeric format, you want to change
it, this is where you can explicitly do so in a SQL statement that you create, and
those are the explicit conversions.
Now some of the categories – touched on them already – but exact numbers and/or
approximate numbers; these are numeric categories.
But in some cases, you don't know the exact value.
You know, you might need to just enter an approximate value.
And a very good example of an approximate number is the value for pi.
You know, you cannot assign an exact value to the number pi.
So sometimes you just have to put in estimate.
Exact numbers are exactly that.
If you have a quantity and somebody orders five of something, that is an exact
number.
Date and times can be stored.
Character strings are basically just textual information.
Unicode character strings are for multilingual support, usually.
Binary strings, CLR is Common Language Runtime for developers usually and spatial
data types for geographic type of information such as GPS systems.
In SQL Server, the specific data types include, and this is only a small subset,
but money for when you're entering currency values, datetime for any kind of date
and/or time information, int is short for integer or a numeric value, char and
varchar are both for string types; character is what that stands for.
The char is used when you know exactly how many characters are going to be entered
such as an abbreviation.
Common example here, if you look at the postal information for a state or a
province, there is usually a two-character abbreviation.
So you can always specify only two characters.
But for a person's last name, for example, you have no idea how many characters
that are going to be, so that is a variable character field.
It allows for flexibility.
Boolean is a yes/no, on/off, true/false, always just one of two possibilities.
Float is a numeric type that usually has very high decimal places associated with
it; scientific notation.
And bit is a one or a zero.
So again those are just a couple of examples of some of the data types.
But every time you define a new field, you have to specify what kind of data is
being stored in that field and that's your data type.

Data Integrity and Constraints:
Data integrity is an approach whereby you ensure the information in your database
is correct and accurate.
There are four different categories:
1. Entity integrity typically refers to the uniqueness of a row, for example,
the primary key.
This ensures that you only ever have one unique customer number one.
You don't ever want to see two customers with the same ID.
2. Domain integrity refers to all of the collective values in a particular column.
Now this might seem similar to entity integrity if you're talking about a primary
key, for example.
If you looked at all of the IDs, you would want to make sure that there are no
duplicates.
But it doesn't just have to be for a primary key.
You might, for example, be storing a person's credit card number; that would also
be something that you would want to ensure is unique.
So if you looked all the way down to the column for every credit card entry, you'd
want to ensure that there were no duplicate values.
Now there's other examples of domain integrity – that's just one.
Some other ones might be something as simple as a not null.
You might want to enforce some kind of entry for any particular column;
that's another example of domain integrity.
So if I look down the credit card type of field, not only can there be no
duplicates, but there must be a value of some kind.
This is another example of domain integrity.
It might also just be a range of acceptable values such as date entries, for
example, date of birth must be either today or back.
You can't enter a future date for date of birth.
So those are several examples of domain integrity.
3. Referential integrity refers to a related record from one table connecting to a
related record in another table.
So this is typically where you see a primary key also used.
But in this example, you see in the graphic, a customer ID uniquely identifies the
customer.
The Order Number uniquely identifies the order.
Those are the two primary keys.
But in the Orders table, you see a reference to that customer who generated that
order.
That is what's known as the foreign key, and we'll talk about in a moment.
But the customer value that you enter in the Orders table is the ID of the
customer that comes from the customer table.
That's referential integrity, and it ensures that you can only create orders for
customers who exist in the Customers table.
So in this simple example, we see there is only three records for the Customers
table.
So let's just assume they are customer 1, 2, and 3.
Hence, in the Orders table, you could not put an order in for customer number 4.
They simply don't exist.
4. User-defined integrity is any other role that you defined as per your business
needs or the logic that you want to implement in your database, and it really can
be just about anything.
Now constraints are methods by which you enforce the integrity, and we've already
talked about a couple of them.
Primary key is by nature a constraint.
If you assign the primary key attribute to a field, it will automatically not
allow you to leave it empty, nor will it allow you to enter duplicate values.
So you are constrained in the values you can create.
The foreign key, again, references the primary key of another table to maintain
the connection, the relationship between the data.
Unique keys are used to maintain uniqueness not, just for a primary key, but again
that credit card example.
You want to make sure that those are kept unique so it will not allow duplicates.
Indexes helps to search, speed up searches and sorts, but in fact, it is indexes
that maintain the uniqueness of fields as well.
But we'll talk about indexes in a lot greater detail later on, but they do, in
fact, help the performance of your database as well.
And triggers can be used to execute code automatically in response to some kind of
a modification, so that if you change a particular value, it can trigger
additional changes elsewhere in the database.
Now specifically the primary key, it is again the unique identifier for a row, and
only one primary key can exist in a table.
And the columns that are using the primary key cannot be left empty.
Not null, is what that's referred to, but those are some of the inherent
characteristics of a primary key field.
A foreign key is used to link the tables.
And a foreign key again is always the primary key from some other table.
So columns using the primary key are also used to create the foreign key.
And again in this example, customers' ID number is their primary key, but in the
Orders table, the reference to customer uses the ID field from the Customers table.
Hence it's the primary key in the Customers table, but it's the foreign key in the
Orders table.
So it simply creates a unique constraint in that same or any other table.
You must reference the unique customer that owns this particular order.
But the columns that are using the foreign key can be left null, and it can also
repeat.
In other words, customer number one can generate many orders.
So if you look at the Orders table, and again in this example, there is only three
simple records here, but you could imagine that customer number one generated all
three orders.
So even though order number one is unique and order number two is unique and
order number three is unique, the customer ID for all three of those might be
customer number one.
So it can repeat. It could also be left null.
Now that's generally not desirable because what it would look like would be order
number one was purchased by nobody.
That's generally not desirable, as mentioned, but customer number one might not be
in your database forever.
You might delete customer number one.
In that event, the order that they made could be removed, or you could just remove
the ID.
Now again, generally you try to protect against that, but there are a situations
where it might arise where foreign keys might be left null.
But you need to make sure, if you're going to allow that, that there is no
verification for null values.
So in other words, you need to make sure that the column is allowed to accept
nulls, but that's up to you.
Some additional constraints.
Unique constraints to simply force uniqueness in any kind of non-primary key
column, and again the credit card was the example there.
A unique index is also still unique, but it indexes the row as well, which again
we will talk about.
But it effectively sorts the row in some kind of fashion, so that it's very easy
to retrieve values a lot more rapidly.
And finally, triggers can be used.
Again, that can simply respond automatically to some kind of table modifications.
So you may change A that triggers change B and so on and so on.
So all those constraints can be used to help maintain the integrity of your
database.

Table Design:
We're going to take a look now at some of the fundamentals of table design.
But before we can get to that, you do need a database in which you can create
that table.
But that's very simple in SQL Server Management Studio.
You can simply right-click the Databases folder and choose New Database.
Now we won't worry about all these properties at this point.
We're just looking at table construction.
So all you need to do is provide a name and that's good enough to get started.
So let's just call this Sample_DB.
And as long as you have a name, that's all you have to do.
Click on OK.
That will create a database for you and you're ready to get started.
Now as far as table design goes, this is something that requires extensive thought
and planning and you would really want to do this on pen and paper first before
you just jump in and start creating tables.
But for some of the fundamental concepts, we can just go ahead and create a table
by expanding our Sample_DB, and there you see, Tables.
So we can just right-click, choose New - Table, and we're ready to get started.
So we're just going to cover off some of the basics when it comes to table design.
Now the first thing you see here, is it obviously wants a Column Name that you can
pretty much use anything, but let's assume this is a customer type of database.
So the first thing we want to do is to ensure that there are no duplicate values
anywhere in the table.
This is typically accomplished by the use of a primary key.
So a very common approach is to create some sort of identification field first.
So I'm going to go with Customer_ID.
Now very quickly, the use of the underscore here.
It's not required, but it is a very common standard implementation in databases
that you not use spaces.
All of the administrators and developers out there will expect to see either all
one word or some kind of character that separates different words within a name
such as the underscore.
You can see here, in fact, the names of the other databases have no spaces, and
that's usually because developers always want to avoid spaces.
Some people might use them and some others would not.
You will save yourself a lot of headache if you just avoid spaces.
So there is the name.
The Data Type, if you hit your Tab key, it will automatically select a Data Type,
and the nchar is a character-based Data Type, in this case, of 10 characters
maximum.
Now n simply stands for national, and it refers to a unicode-based character set,
which is supported by multiple languages.
We won't worry too much about that.
But what I'm going to do in my case is just set an integer-based value.
So I can scroll down and I can find int, scroll up, for integer.
And that allows me to just put in a simple number.
Now we're going to come to some other properties of the columns in an upcoming
demonstration, but for the time being, I'll leave it as an integer value, but look
at the null column here – Allow Nulls – says Yes.
In other words, I am allowed to leave it blank.
Now you don't want that to be done either when it comes to the identity field.
So you can accomplish two goals here.
You can ensure that there are no duplicates and no nulls by the use of a primary
key.
And there you see is the option to 'Set Primary Key' in the toolbar.
So you simply have to click on that and watch what will happen to the Null option
here.
It automatically turns off.
And you see down here – Allow Nulls – now says No.
You are not allowed to implement a null value when you are dealing with a primary
key. There must be an entry.

So there's two, as I mentioned, two goals accomplished.
We will have no duplicate values and no ID field will be allowed to be left blank.
Now as for the remaining columns, it is certainly up to you.
But there are number of different approaches that you'll find when it comes to
table design.
But one of the things that you often want to implement as well is to take any
particular field that can be broken down into smaller units and do so.
In other words, don't do something like this:
FullName and then enter in their first and last name in the same value.
That way, if you do so, you cannot search or sort by just the person's last name,
for example, and you might often want to sort alphabetically by a last name.
Well this, kind of, prevents that.
So what you want to do is to break them down as small as possible.
So we want First_Name and Last_Name.
Now as far as the Data Types go here, again, we'll talk about this in greater
detail, but since you don't know how many characters are going to be in somebody's
name, then a good candidate Data Type there is the varchar – that's variable
characters.
So I'm going to set that for both of them.
But I probably don't need 50 characters; that's what this value is here.
So it is variable but only up to a maximum of 50.
So what I can do is just make this a more reasonable value.
First_Name, 20 should be okay and Last_Name, maybe, 30.
And this will help to save some space in the overall size of your database.
Now if it's a very small database, you don't have to be as concerned with this.
When you start getting up into the server-class databases that have millions upon
millions of records, a savings of 20 to 30 characters per entry adds up to be
quite a lot.
Now you might also see the same thing with something like Address.
You probably would not want to put their entire address into one field because
then you could not search or sort by, let's say, their state or province.
So you would probably want to break this up again into something like
Street_Address.
And I won't worry about the Data Type from this point on.
Then you might see something like City, State or Province, and something like
Zip or Postal Code.
So those are some of the basic fundamentals of designing tables.
You definitely want your primary key on there to ensure uniqueness and ensure that
there are no nulls.
You generally want to try to break things down into their smallest units possible,
and of course, you do want to set the appropriate Data Types and then determine
whether or not you're going to allow null values.
So in this case, you see all of them are allowing nulls.
It's up to you, but you generally want to then selectively go through and say,
well, you know what, I want to ensure that they must enter at least their first
and last name, for example, in this case.
Now let's also put in one more field.
Let's juts put in Phone_Number or perhaps an e-mail address or anything along
those lines.
So again you know, I would probably go back after the fact and clean up the Data
Types here and set something a little more specific, but we'll talk about those
later on.
For the time being, we just want to see how you can get in there, create a table,
and follow some of those basic rules of primary key for uniqueness and null
ability and breaking down fields into their smallest constituent component.
So with that done, I'm going to close this table.
I'm going to say Yes to save it.
We'll make some changes, of course, as we go through here.
And let's now just call this Customers_Table. Click on OK.
And there we have a simple but functional table.

Column Design:
Now that we have a basic table design, we're going to take a look at some
fundamentals of column design within that table.
Now you can access the properties by right-clicking the table you just created
and simply choosing Design, and that brings you straight back into the designer
where we created it in the first place.
Now with respect to the properties of any given column, certainly one of the
things that you want to set straight away is the appropriate Data Type, and we're
still going to get to that coming up.
But there are some other properties that are particularly useful, given a
particular type of data.
And the first one we're going to look at is what's known as an identity in SQL
Server.
Now as far as a field such as Customer_ID goes, that, sort of, indicates that this
is something that's used to identify the customer and it absolutely is.
And that again is accomplished by the use of primary key, which ensures that there
are no duplicate values and no null values.
But as it stands right now, we have to manually enter an integer value for the
customer.
Now that could be fine. Maybe the Customer_ID is 24361.
In that case, an integer value is fine.
But you might also want to have the database enter a value for you automatically.
And in SQL Server, that's what's known as an identity property.
In some other databases, you might find something like an auto increment or
something similar to that.
But if we scroll down to the Column Properties here, you'll find that there is
one that's called Identity Specification. Currently it says No.
It is not using that property.
But if we extend this, we see right there, Is Identity is set to No.
Well you can just change this to Yes.
And watch what happens as soon as you do.
You see right now the Identity Increment and Seed are grayed out.
I can't access these fields, I can't type anything in there.
But as soon as I change this to Yes, then you see that you get these two options.
So the Seed is the starting value.
The Increment is then what it will count by.
So by enabling it in it's default state here of 1 and 1, my first customer will be
customer number one, my second one will be customer number two, customer number
three, and so on and so on until I have entered all of my customers.
Now you can change these values, if you want to start with something a little
higher.
If you don't want to say, customer number one, you can change this.
For example, I can put in customer 100 as my first value.
And then I could increment by 10 if I want to.
That will give me customer 100, 110, 120, 130, 140.
It doesn't matter; you pick the values.
For simplicity sake, I am just going to leave them at their default values of 1
and 1.
Now this can also be used for any other column.
It does not have to be a primary key.
It's anything that you feel would benefit from an automatically incrementing value.
Now the other option that you can set, of course, is the null ability and that is
entirely up to you.
But if you are going to Allow Nulls, you have to keep in mind that it will allow
the end user to leave it blank.
So if that's acceptable, then by all means go ahead and do it.
Something like a fax number, for example, if that was stored, not everybody has a
fax number.
So you would certainly want to Allow Nulls.
But if you want to force the user to enter something, then do not Allow Nulls by
turning it off. So again that's entirely up to you.
Now another thing you can do to help the integrity of any given table with respect
to the values in a column is that you can enter in an automatic value for them,
if it’s something that's very common.
Now the user is allowed to override this if they want to, but it can help to keep
the values consistent.
If it’s something that is commonly entered, so as an example, looking at State or
Province.
If this is not a particularly large business and all of my business is done within
the same state or province as the one I am in, then I can save a bit of time and
help to ensure consistency by entering what's known as a default value.
So I'm going to scroll back up here and you will see near the top, right there,
Default Value or Binding.
So the whole idea is to simply save a bit of time for the users and to help for
consistency sake.
This way, if it's always the same entry, they can just skip over it.
So let's imagine you do business in New York State, then you can simply enter in
NY as the value, and it will automatically enter that value for every new record
that you create.
Now if it's something different, the user can absolutely change it.
Default values are not permanent or not read-only – it's just something that will
save a bit of time.
So any kind of value that you have that is fairly consistently this same value,
that's a good candidate for the default value.
Now finally, before we get into too much more detail about the Data Types, one
other thing that's very common, and this is a good example.
Is if you have a value that is consistently the same size, then you can also help
to save some space and ensure the integrity of the database by specifying exactly
that size.
If you go with the post office abbreviations for every state or province, then it
is always just two characters.
That way, you never allocate any more than two and you will always help to ensure
that exactly two are entered.
So you don't get any typos, for example, somebody hitting an extra character by
mistake and putting in three or four or something along those lines.
So you know, again the whole idea is to help keep all of the data consistent
within any given column.
So the Identity Value or the Auto Increment in some other databases, the Default
Value and the Size, and, of course, the Data Type that goes along with that can
really help to build a nice consistent and user-friendly table for your end users
when entering records.

Table and Column Properties:
We're going to take a bit of closer look now at some of the properties of tables
and columns.
And I want to start with one that's known as Collation.
Now this is something that deals with how characters are treated, if you will,
when searched or sorted or compared against each other.
When you issue a query statement, for example, you have to specify criteria that
says, I'm looking for particular values.
Well Collation deals with how what you supplied is compared against that which is
in the database.
And for the most part, it deals with things like case sensitivity and accent
sensitivity, particularly if you are in a multilingual environment and you need to
support these different languages.
Now it's typically something that is set by whoever does the installation of the
product, but it can be set per database and even right down to the per table and
even sometimes the column level, but usually you don't need to be that specific.
Now I'll show you where you can just find it.
First of all, if you right-click on the table and go to Properties, you will find
it under Extended Properties.
Right there, it says Collation.
Now this is the default Collation that was installed with this particular product
and it generally supports languages that are Latin derivative.
The CP1 stands for Code Page1 and that's really beyond what we need to get into
at this point, but it's just how pages are written to disk, if you will.
But these last four characters here are the important ones.
CI is case insensitive.
AS is accent sensitive.
So case insensitive means that if, for example, I was to search for a person's
last name.
If I did not capitalize the first letter of their last name in my criteria, it
would still work if it was case insensitive.
But if it was case sensitive, I would have to make sure I get the case correct
for any results to come back as matching results.
Now accent sensitive means that I must get the accents correct if I'm in a lingual
environment that uses accents such as French.
But you can change these, as mentioned, but it depends on where and when you set
it.
You can see that, in here, I don't have the option to change this.
You can't just type in a new Collation here; you'd have to choose it from a
drop-down.
But this is a function of what was set at the database level.
So I'm just going to Cancel this quickly.
And if I right-click on the entire Database and go to Properties, under the
Options page there you can see a pick list of all of the available Collations.
And as you can see, there's quite a few.
So for the time being, I just wanted to show you how you can find out what it is.
I could change it here, but changing it would only change it from this point
forward.
In other words, tables and columns that were already created do not change.
I would have to manually write some code to change those existing objects.
So really, at this point, it's just a matter of being able to find out what it is,
so that you can be assured when you are writing some queries that your queries are
going to work, even if you don't match the case, and/or, of course, if you do
have to match the case.
Because if you find one, you see that here is CS, that is case sensitive.
So somebody may have created the database with that Collation.
And if that's the case, you have to make sure that all your case matches when
issuing out criteria.
So that's one of the first properties.
Now if we look at the table itself, you can right-click on it again and choose
Properties.
You see there's quite a few, and you can just find out, of course, what properties
have been set on any given table by just going through each of these pages.
Now again, at this point, I'm not really going to get into what all of these are
all about but rather just how to find the values, so you can gain better insight
into the construction of your tables.
So it's just simply a matter of right-clicking and choosing Properties and
browsing through these pages. A lot of these cannot be changed at this point.
Once you create the table with those Properties, it's pretty much done unless
you're willing to drop and re-create or use some fairly extensive code, but that's
how you can find out.
Now each individual column in the table also has properties.
And you see, if you just expand them here, it tells you some of the main
characteristics right here.
We see our Customer_ID is the primary key and that's what the little key icon
indicates.
Its data type is integer and it will not accept nulls.
So you get some basic properties right here.
But if you do want to really find out some more information, again, you can just
right-click, choose Properties, and it will tell you everything about that
particular column, including things like the Identity and the Identity Seed and
Increment, which we set earlier.
So that's where you can again just see the values...I cannot make changes here.
But if you do want to make changes, you can certainly just go into your designer
again.
I can right-click and I can choose Modify.
That brings me right back into the table design.
I can also just right-click the table itself and choose Design. Same interface.
So one of the other properties that is certainly worth having a closer look at is,
in fact, the Data Type.
Now we've touched on a few of these already, but these can be changed at any point
in time.
So there is no restrictions, you can hit your drop-down here and simply choose to
a different data type.
But do be aware that the existing information that's already entered into any
cells of the table may not conform to the change that you make.
For example, if you decide you want to shrink the size of this.
Let's just say, for example, I want to make these 5 characters.
Well if there is a value in there that is already set to 10 characters, then
that's going to cause problems.
It's going to tell me that there is information in there that would have to be
truncated or shortened to accommodate that value.
So there is probably a lot of instances where you may not want to do that, but
it’s certainly up to you.
But with respect to the Data Types themselves, you see there is a fairly extensive
list here.
And again, we really don't have the time to go through all of them.
But the properties of the Data Types that you do need to be aware of deal with
the size.
So you're seeing a number of them that have these numeric values after them
indicating how large a value they will accept.
Now the smaller, the better in terms of the overall size of your database.
So if we can save some space here, that's definitely going to help, particularly
if it's a very large database with millions of records.
But you obviously can't go too small.
And again choosing the correct Data Type in the first place is also particularly
important.
Now what I'm going to do here in terms of giving you an idea of what these are all
about.
In fact let's just go to the web page.
You can just search for these.
I just did a search for SQL Data Types and there is the MSDN document supporting
this.
Chances are you have this installed in your SQL documentation as well, but this
just gives you an idea of the categories of the Data Types and some examples.
And then you see here that there are Exact Numerics, there are Approximate
Numerics, there's Date and Time, there is Character and String, and so on.
So you can just click on any one of these, and it will give you all of the
properties and values that are appropriate for that data type.
So it will take a little bit of extra research, but knowing the data type and
knowing the appropriate size will definitely help you when it comes to designing
effective tables that are efficient and, of course, appropriate for the
information that you want to store in your tables.

Understanding Relationships:
The next component that we'll discuss with respect to database fundamentals is
the concept of relationships.
Now when it comes to the tables in your database, this again is something that you
want to try to map out and plan very much ahead of actually creating the database.
So it's again very much done on pen and paper, if you will, before you ever get
into an interface.
But before we even get to that stage, you need to understand the types of
relationships that you will find.
And this is something that is typically indicated by the normalization process.
Now to help in the demonstrations here, I have downloaded another database
because, plain and simple, it's a much smaller database and it's much more simple
in its layout and its design.
And it's known as the NORTHWND database.
Now if you've ever used Microsoft Access, which is just the desktop version of a
database application, you may have already seen this database.
But it is fully supported in SQL as well, and it's freely downloadable.
So you can absolutely just go ahead and download that and mess around with this
database as well.
So let's just take a quick look at the tables here.
And you see there is not nearly as many as there is in something like
AdventureWorks, which is another sample database.
We see the tables there are quite numerous compared to what's in NORTHWND.
So as mentioned, this is a much simpler database.
But when it comes to the relationships, the concepts are still the same.
Now in our sample database that we created, we made a simple Customers table, and
we have the same thing here.
So we can expand this, and we see that the columns are fairly similar; we're just
storing the company name, their contact information, and address information, and 
that's it.
And that's perfectly fine. Now this is a commercial type of organization.
So the customers generate Orders.
So right there we see a relationship.
Now to actually view this, what we can do is use the Database Diagrams feature
that is right there below the name of the database.
And AdventureWorks has this feature as well, all of them do.
There you see our diagrams, and this allows you to just map things out.
Now another option you can do is to create a view that has a bit of a diagram
application built into it.
But just for the sake of making it easy to see, I'm going to go ahead and create
a database diagram.
So I'm just going to right-click and choose New Database Diagram, and it simply
asks you to add in the tables.
So I'm going to go ahead and add in the Customers table.
And I can just hit the Ctrl key and I can select the Orders table at the same
time, and I can Add them both.
Close this and this will show you that there is a relationship between the two
tables.
And basically it is this line here.
And in fact you see, if I mouse over that line, a little balloon pops up that
tells me there is a relationship between the Foreign Key Orders, and Customers and
Orders.
So in essence, what it comes down to is that you have primary key fields.
Their job, as mentioned, is to uniquely identify every record in this table.
So this uniquely identifies my customers. That's it.
But my customers generate orders.
So over in the Orders table, we have an OrderID field and this is the primary key
of this table, which uniquely identifies every order. That's perfectly fine.
That's exactly what we want.
But one of the things we need to know about the order is which customer ordered
it.
And that is this field right here; that is the foreign key of this table.
So any time you see a primary key of some other table in this other table, that
in almost every case, indicates that there is a foreign key.
And in fact, we're seeing another one right here with EmployeeID because not only
did a customer have to generate the order, an employee had to sell it.
So that is another field – that's a foreign key relationship.
But we won't worry about that for the time being; let's just focus on the
Customers and the Orders.
Now what are you seeing here is the key icon on this side and then a little –
this is actually meant to be an infinity symbol – on this side.
Those icons mean that this is what's known as a one-to-many relationship.
Now that, in essence, means that one customer – that's the primary side –
generates many orders.
That is the standard one-to-many relationship.
And then if you work it in, kind of, a reverse fashion, if you looked at any one
of the many orders, it should be traceable back to a single customer.
In other words, a single order can not be owned by two customers.
It has to be traceable back to the unique customer that generated that order,
and that is a standard one-to-many relationship.
But that's not the only type of relationship that you might find.
There is also a many-to-many relationship.
But this is something that needs to be resolved in databases because it generally
doesn't work.
Now I'm going to zoom out a little here.
I'm just going to right-click and choose Zoom, just so we can see a few more
tables.
And I'm going to bring in a couple more.
Now what you might think about an order just logically is that if somebody is
going to order something, they need to order a particular type of product that
they are looking to buy.
And if you go through the fields here, there is nothing here about the product.
So I'm just going to remove the Customer entirely for a moment.
And then I just put our Orders over here and I'm going to add in another table.
And the Products table contains the products that this organization sells.
So we're going to Add that and Close here.
So you might think, okay well, an order should contain products.
But note that there is no relationship here.
There is no foreign key for the product; there is no reference to the Order in
the Products table.
And you might think about it in terms of this one-to-many business.
Well if I look it any one single order, it is certainly very plausible that I
might order any number of products on that order.
You can imagine somebody is saying I want one of this, two of these,
five of those, and so on and so on, all on the same order.
So one order can have many products. Seems good so far.
But if you reverse it, any one product can show up on multiple orders as well and
that is a many-to-many relationship.
And there is basically no way to accommodate that in the existing structure.
One Order can have many Products; one Product can be on many Orders.
That basically doesn't work.
So what you have to do is introduce yet another table.
And in this example, it's called the Order Details table.
If we Add this one and watch what happens with the relationships, all of a sudden
they appear.
We'll Close this and make a little more sense out of this.
And you see what happens is that this is another table that sits in between the
two, and there are relationships to both.
This is often referred to as an intersection table.
And what you see there now is the OrderID primary key is also here in the Order
Details table in a one-to-many scenario, and the ProductID is also included in a
one-to-many and these two one-to-many relationships resolve the many-to-many
problem.
And then there is a few other fields here as well, but that, in essence, takes
care of the issue.
And then both of these fields together are the primary key of this table.
It requires both unique values to generate an overall unique record.
So order number one could have product number one, order number one could also
have product number two.
But when you take those together, that is a unique record and you resolve the
many-to-many issue.

Lesson Test:
Q1: If a primary key is added to a table, what attributes does it provide?
	Acts as a unique identifier, prevents null values

Q2: If the Identity Specification is set to "Yes", which of the following
    properties can be controlled?
	Identity Seed and Identity Increment

Q3: Given the Collation default SQL_Latin_General_CP1_CI_AS, what does the end
    CI_AS stand for?
	Case Insensitive_Accent Sensitive

Q4: Match the description to the Data Integrity category:
	Referential integrity: related records from one table to another table 
	X Entity integrity: uniqueness of collective items in a row
	User-defined integrity: any rule defined in relation to a specific dataset
	X Domain integrity: uniqueness of collective items in a column

Q5: Which of the following commands are used to manually handle explicit
    conversions from one data type to another?
	CAST and CONVERT

Q6: What is the relationship between these tables, given the symbol linking them?
    Customers{PK:CustomerID} PK-INF Orders{PK:OrderID}
	One-to-many
-----------------------------------------------------------------------------------------
DML Statements:
SQL, DDL, and DML:

Using SELECT Statements:

Filtering Results:

Ordering Result Sets:

Using Aggregate Functions:

Lesson Test:
Q1: If a primary key is added to a table, what attributes does it provide?
	Acts as a unique identifier, prevents null values

Q2: If the Identity Specification is set to "Yes", which of the following
    properties can be controlled?
	Identity Seed and Identity Increment

Q3: Given the Collation default SQL_Latin_General_CP1_CI_AS, what does the end
    CI_AS stand for?
	Case Insensitive_Accent Sensitive

Q4: Match the description to the Data Integrity category:
	Referential integrity: related records from one table to another table 
	X Entity integrity: uniqueness of collective items in a row
	User-defined integrity: any rule defined in relation to a specific dataset
	X Domain integrity: uniqueness of collective items in a column

Q5: Which of the following commands are used to manually handle explicit
    conversions from one data type to another?
	CAST and CONVERT
-----------------------------------------------------------------------------------------
Multi-Table Queries:
Using Inner Joins:

Using Outer Joins:

Using Cross Joins:

Combining Result Sets:

Manipulating Result Sets:

Lesson Test:
Q1: If a primary key is added to a table, what attributes does it provide?
	Acts as a unique identifier, prevents null values

Q2: If the Identity Specification is set to "Yes", which of the following
    properties can be controlled?
	Identity Seed and Identity Increment

Q3: Given the Collation default SQL_Latin_General_CP1_CI_AS, what does the end
    CI_AS stand for?
	Case Insensitive_Accent Sensitive

Q4: Match the description to the Data Integrity category:
	Referential integrity: related records from one table to another table 
	X Entity integrity: uniqueness of collective items in a row
	User-defined integrity: any rule defined in relation to a specific dataset
	X Domain integrity: uniqueness of collective items in a column

Q5: Which of the following commands are used to manually handle explicit
    conversions from one data type to another?
	CAST and CONVERT
-----------------------------------------------------------------------------------------
Working with Data:
Inserting Data:

Bulk Inserts:

Updating Data:

Deleting Data:

Transactions:

Lesson Test:
Q1: If a primary key is added to a table, what attributes does it provide?
	Acts as a unique identifier, prevents null values

Q2: If the Identity Specification is set to "Yes", which of the following
    properties can be controlled?
	Identity Seed and Identity Increment

Q3: Given the Collation default SQL_Latin_General_CP1_CI_AS, what does the end
    CI_AS stand for?
	Case Insensitive_Accent Sensitive

Q4: Match the description to the Data Integrity category:
	Referential integrity: related records from one table to another table 
	X Entity integrity: uniqueness of collective items in a row
	User-defined integrity: any rule defined in relation to a specific dataset
	X Domain integrity: uniqueness of collective items in a column

Q5: Which of the following commands are used to manually handle explicit
    conversions from one data type to another?
	CAST and CONVERT
-----------------------------------------------------------------------------------------
Practice: DML Statements
Exercise: Using DML Statements

-----------------------------------------------------------------------------------------